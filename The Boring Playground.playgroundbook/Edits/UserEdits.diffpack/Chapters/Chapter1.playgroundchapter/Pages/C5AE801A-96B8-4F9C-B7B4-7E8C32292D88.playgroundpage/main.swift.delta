<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>BaseFile</key>
	<string>Chapters/Chapter1.playgroundchapter/Pages/Template.playgroundpage/main.swift</string>
	<key>Diffs</key>
	<array>
		<dict>
			<key>ModifiedContent</key>
			<string>

/// Until there, every lines contained a boolean comparison and the printing of a boolean value.

/// # Now, we will completely change the topic and the level of difficulty.

/// Let's imagine we want to save multiple informations about a person like "Carlo".
/// We can save everything in as many variables as we need, for example:

var carloName: String = "Carlo"
var carloAge: Int = 19
var carloHeight: Int = 180

/// But if you start creating 3 variables for every person, and that you need to do it manually,
/// it will quickly get tiresome. And you can't really save that into an array.

/// But thankfully, programming languages and especially Swift today, include a set of things and types
/// that enables to save all these kinds of information in one specific place and being able to move them all easily.

/// The first thing we will talk about are ``class`` (classes).
/// Classes are a way to handle a various set of data related to a specific topic.
/// The class is a specific type of value that enables you to create other type of value.
/// It's like declaring a function, but with more stuff inside it.
/// Right now, we will create a class that defines a person, but into the code:

/// We start by declaring the class creation by using ``class`` keyword followed by the actual name of the new class `Person`.
/// Then we use `{` and `}` to create a new block of code.

class Person {

    /// Then we use almost the same variable as we declared specifically for Carlo earlier

    var name: String
    var age: Int
    var height: Int

    /// But here comes the difference with the 3 easy variables.
    /// Classes need `initializers` to be created.
    /// The thing we just did is just *declaring* a class named Person.
    /// But to create a person, Carlo for example, with every information we know about it,
    /// we have to use the initializer to create a new person with the provided information.
    /// An initializer is basically a function that needs to be defined inside classes.
    /// Initializers **HAVE TO** define the value for every variables in the class declaration.

    init(name: String, age: Int, height: Int) {

        /// ``self`` refers to the person we're initializing right now.
        /// It is often useful and preferable to use ``self`` to refer to properties of a class.
        /// Here, we **NEED** to use it to distinguish the ``name`` property of `Person` from the `name` argument from the initializer.

        self.name = name
        self.age = age
        self.height = height
    }

    /// One another cool thing of classes:
    /// You can specify functions that only this class can use.
    /// For example, we wrote some functions to greet every persons contained in an array earlier,
    /// Here we can just write a function that will greet this person specifically:

    func greet() {
        print("Hello \(name)!")
    }

    /// But we can many more things and complex functions!

    func greetSomeone(anotherPersonName: String) {
        print("Hello \(anotherPersonName)! My name is \(name)")
    }

}

/// We now have a new *type* called Person. And we can use it normally as any other type.
/// To initialize a new person, you just have to "call" the Person initializer function `.init(...)`.
/// This looks like this:

let carlo: Person = Person.init(name: "Carlo", age: 19, height: 180)

/// By using the dot `.` between ``Person`` and ``init``, we're telling Swift to access the ``init`` function inside the ``Person`` *class*.
/// But in reality, what we just wrote is the complex version that nobody is actually using.
/// If you don't want to look weird to your peer developers, just use:

let antonio: Person = Person(name: "Antonio", age: 22, height: 170)

/// This looks better, doesn't it?

/// Now, let's do a quick vocabulary update:
/// Variables we declared inside the *class*, like `name`, `age`, `height` are called **attributes** or **property** in Swift.
/// Functions we declared inside the *class*, like `greet`, `greetSomeone` are called **methods**.
/// ``carlo`` and ``antonio`` are **instances** of the *class* ``Person``.

/// As any variable in this playground, `name`, `age` and, `height` are variable you can access directly and print or use in your functions.
/// Remember that you have to use the dot `.` notation to access data stored inside a class.

print(carlo.name)
print(carlo.age)
print(carlo.height)

/// And, the main goal of everything we just did, was to be able to manage multiple people and their information
/// with as less struggle as possible, and you'll see that it's now become easier:

/// Let's create a list (an array) of people:
/// Don't forget about `[` and `]` to create array and specify the type of a variable.
/// Here, the type `[Person]` defines a list (an array) of instance of the class `Person`.

var presenters: [Person] = [
    carlo,
    antonio,
    Person(name: "Gigi", age: 24, height: 175)
]

/// You can see that you can create class instances at almost any time in the code.

/// Since we now have an array, we can do some array stuff on it. Let's start with a *loop*.

for presenter in presenters {
    presenter.greet()
}

/// This code should be self-explanatory.
/// For each `presenter` of the list `presenters`, execute the **method** ``greet`` of the considered presenter instance.


/// Now if you remember, attributes are just variables stored inside the class.
/// But what is interesting about variables?
/// You can change their values.

print(carlo.age)

carlo.age = 25

print(carlo.age)

/// This is made possible because we declared `Person`'s age as a `var` variable.
/// If you want you can also set it with `let` and see that happens.

/// Now that we have discovered ``class``. Let's dig into something really close yet really different.
/// Let's talk about ``struct``.
/// Structs are a cousin of class, with almost the same way of being created and used but some technical differences.
/// We'll go over technical differences later.

/// To create a ``struct``, it's really similar to a ``class``:

struct PersonStruct {
    var name: String
    var age: Int
    var height: Int
}

/// We just created our first ``struct``. Be proud of yourselves.
/// And you can already see differences.
/// **Where is the ** `init` initializer function? You don't need it with ``struct`` (unless you're doing complicated things).

/// In ``struct``, a default initializer function will be provided and it looks really like the one we use for the previous class `Person`.
/// So we don't need to write it and it will work the same way as if we wrote it.

/// ```
/// init(name: String, age: Int, height: Int) {
///     self.name = name
///     self.age = age
///     self.height = height
/// }
/// ```
















/// ## In Swift, both ``struct`` and ``class`` are used to define custom data types, but they have some key differences in terms of behavior and characteristics.
/// Here's a brief overview:

/// ## Structs:
/// 1. Value Type: Structs are value types. When a struct instance is assigned to another variable, or passed as a parameter, a copy of the instance is made. Each instance is independent of others.
/// 2. Stack Memory: Struct instances are usually stored in the stack memory, making them more memory-efficient for small data structures.
/// 3. Immutability: By default, the properties of a struct are immutable. To modify a property, you need to use the 'mutating' keyword on the method.
/// 4. No Inheritance: Structs do not support inheritance. You cannot inherit from another struct.

/// ## Classes:
/// 1. Reference Type: Classes are reference types. When a class instance is assigned to another variable, or passed as a parameter, both variables point to the same instance in memory.
/// 2. Heap Memory: Class instances are usually stored in the heap memory, which provides more flexibility but may be less memory-efficient for small instances.
/// 3. Mutability: Properties of a class are mutable by default. You can modify properties without using the mutating keyword.
/// 4. Inheritance: Classes support inheritance. You can create a new class that inherits from another class.
</string>
			<key>ModifiedRange</key>
			<string>{1, 8183}</string>
			<key>OriginalContent</key>
			<string></string>
			<key>OriginalRange</key>
			<string>{1, 0}</string>
		</dict>
	</array>
	<key>FormatVersion</key>
	<integer>2</integer>
</dict>
</plist>
